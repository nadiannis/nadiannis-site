---
title: 'Asynchronous JavaScript: Introduction - Part 1'
author: 'Annisa Nadia'
createdAt: '2022-01-01'
updatedAt: '2022-01-01'
summary: 'Pengenalan awal mengenai Asynchronous JavaScript'
image: 'codes.jpg'
---

_Asynchronous JavaScript_ merupakan hal yang kemungkinan besar dipraktekkan dalam membuat aplikasi dengan JavaScript.
Konsep ini membantu dalam menangani hal-hal yang membutuhkan waktu yang lebih lama untuk dieksekusi.
Misalnya, _request_ data dari API, menghubungkan ke _database_, dll.

Artikel ini adalah bagian pertama dari seri bahasan mengenai _Asynchronous JavaScript_.
Pada bagian-bagian selanjutnya akan dibahas mengenai _callback_, _promise_, serta _async_ & _await_.

- Asynchronous JavaScript: Introduction - Part 1
- [Asynchronous JavaScript: Memahami Callback - Part 2](/blog/asynchronous-javascript-callback)
- [Asynchronous JavaScript: Tentang Promise - Part 3](/blog/asynchronous-javascript-promise)
- [Asynchronous JavaScript: Async & Await - Part 4](/blog/asynchronous-javascript-async-await)

Sebelumnya, mari kita ketahui dulu bahwa secara _default_ JavaScript menjalankan kodenya secara _synchronous_ dan _single-threaded_.

## _Single-Threaded JavaScript_

_Thread_ adalah proses tunggal yang dapat digunakan program untuk menjalankan beberapa _task_.
Secara default, JavaScript itu _single-threaded_, yang berarti hanya dapat menjalankan setiap _task_ pada _single thread_ (_main thread_) dalam satu waktu.
Setiap task dalam _main thread_ dijalankan secara bertahap.

Pada gambar di bawah, _Task 1_ dijalankan pertama kali.
Setelah _Task 1_ selesai, maka _Task 2_ dijalankan, dst.

![Test image](/static/images/blogs/asynchronous-javascript-introduction/single-thread.jpg)

Setiap _task_ dapat memiliki waktu eksekusi yang berbeda-beda.
Misalnya, salah satu _task_ dari gambar di atas, yaitu _Task 3_, memerlukan waktu yang lebih lama untuk dieksekusi.
Anggap saja kita ingin mendapatkan data dari _database_ sehingga butuh waktu yang lebih lama.
Jika dibutuhkan waktu yang lama, maka _Task 3_ dapat mem-_blocking_ kode-kode setelahnya.

## _Blocking Code_

Jika terdapat potongan kode program yang berjalan secara _synchronous_ dan kode tersebut membutuhkan waktu yang lama untuk dieksekusi, maka kode tersebut dapat menjadi penghalang untuk potongan kode berikutnya, atau dapat disebut _blocking code_.
_User_ bisa mengira programnya berhenti/ _freeze_ karena adanya _blocking code_.
Itulah mengapa potongan kode tertentu perlu dijalankan secara _asynchronous_ sehingga tidak menghalangi kode-kode berikutnya.

## Jadi, _Asynchronous_ itu Apa sih?

Sesuatu yang berjalan secara _synchronous_ dilakukan secara bertahap dan sesuai urutan.
_Task_ berikutnya belum bisa berjalan kalau task sebelumnya belum selesai dilakukan.

Kebalikan dari _synchronous_, jika berjalan secara _asynchronous_, maka _task_ bisa berjalan tidak bertahap atau tidak sesuai dengan urutan.
Untuk menjalankan _task_ berikutnya tidak perlu menunggu _task_ sebelumnya selesai dilakukan.

Ini contoh kode JavaScript yang berjalan secara _synchronous_.
Jika kode dijalankan, maka huruf a, b, c, dan d ditampilkan secara berurutan.

```js
console.log('a');
console.log('b');
console.log('c');
console.log('d');

/*
Output:
a
b
c
d
*/
```

Kemudian ini contoh sederhana konsep _asynchronous_ dengan kode JavaScript.

```js
console.log('a');

setTimeout(() => {
  console.log('b');
}, 4000);

console.log('c');
console.log('d');

/*
Output:
a
c
d
b
*/
```

Dapat dilihat bahwa kode untuk mencetak huruf b diletakkan dalam suatu _callback function_.
_Callback function_ tersebut merupakan argumen dari fungsi `setTimeout` sehingga huruf b baru akan dicetak setelah 4000ms atau 4s.

> Fungsi `setTimeout` memanggil suatu fungsi setelah beberapa waktu. Fungsi `setTimeout` dapat disebut _asynchronous_ karena dapat memutus alur kode yang _synchronous_, tapi sebenarnya tidak akan dieksekusi pada _thread_ yang terpisah. Fungsi `setTimeout` merupakan Web API (pada _browser_) dan C/C++ API (pada Node.js).

_Output_ dari kode di atas adalah tampilan huruf a, c, d, dan b.
Perhatikan bahwa huruf c dan d dapat dicetak lebih dulu tanpa harus menunggu selesainya potongan kode sebelumnya.

## Bagaimana Konsep _Asynchronous_ Bisa Bekerja pada JavaScript?

Sederhananya, kode-kode JavaScript dieksekusi di dalam _JavaScript Engine_, yang terdiri dari _Execution Context_ dan _Call Stack_.
_Execution Context_ adalah lingkungan di mana setiap kode JavaScript dieksekusi.
Sementara _Call Stack_ digunakan untuk menyimpan semua _Execution Context_ yang terbentuk saat mengeksekusi program.
Seperti struktur data stack pada umumnya, _Call Stack_ menerapkan konsep LIFO (_Last in, First out_).

_JavaScript Runtime Environment_ pada _browser_ atau Node.js memiliki Web API atau C/C++ API, _Callback Queue_, dan _Event Loop_.
Hal-hal tersebut bukan bagian dari _JavaScript Engine_ sehingga _task_ dapat dijalankan secara _asynchronous_ di dalam Web API yang kemudian diletakkan di _Callback Queue_.
Selanjutnya saat _Call Stack_ kosong, maka _task_ di dalam _Callback Queue_ diletakkan kembali ke dalam _Call Stack_ menggunakan _Event Loop_ untuk dieksekusi.

Pada modern Web APIs terdapat gaya baru untuk kode _asynchronous_, yaitu _promise_.
Diperkenalkan _Micro-task Queue_ yang digunakan oleh _promise_ di JavaScript.
Perbedaaan antara _Callback Queue_ dan _Micro-task Queue_ adalah prioritasnya, di mana _Micro-task Queue_ memliki prioritas yang lebih tinggi daripada _Callback Queue_.
Artinya, _promise_ di dalam _Micro-task Queue_ akan dijalankan lebih dulu daripada _callback function_ di dalam _Callback Queue_.

Ya, jadi mungkin segitu dulu untuk bahasan mengenai pengenalan _Asynchronous JavaScript_.
Di artikel-artikel selanjutnya, akan dibahas mengenai _callback_, _promise_, serta _async_ & _await_.
